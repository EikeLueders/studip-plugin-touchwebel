// Generated by CoffeeScript 1.3.3

/*
Declare the global $App object (the initial $ indicates a global
variable). We need it to dynamically navigate between routes etc.
*/


(function() {
  var $App, $Session, AppRouter, SessionModel, compileTemplate, requireSession;

  window.$App = $App = {};

  /*
  ***************************************************************************
  * MODELS
  ***************************************************************************
  */


  /*
  SessionModel is not the typical Model as one does not want to store
  the password on the client side. So this is just a simple class to
  hold the user`s name and id and to create a new instance by providing
  the credentials.
  */


  SessionModel = (function() {

    SessionModel.authenticate = function(username, password, done, fail) {
      /*
          Instead of interacting with the RestIP plugin, we have to call our
          mothership to login as the RestIP plugin does not allow
          unauthorized endpoints as of now.
      */

      var xhr;
      xhr = $.ajax({
        url: "" + PLUGIN_URL + "login",
        dataType: 'json',
        data: {
          username: username,
          password: password
        },
        type: 'POST'
      });
      /*
          Call the fail callback, if there is one.
      */

      if (fail) {
        xhr.fail(fail);
      }
      /*
          Create a new SessionModel off the response and call the done
          callback, if there is one.
      */

      xhr.done(function(msg) {
        var session;
        session = new SessionModel(msg);
        if (done) {
          return done(session);
        }
      });
    };

    function SessionModel(creds) {
      this.id = creds.id, this.name = creds.name;
    }

    /*
      Just for convenience. In Stud.IP unauthorized users have an empty
      name and "nobody" as their id.
    */


    SessionModel.prototype.authenticated = function() {
      return this.id !== "nobody";
    };

    return SessionModel;

  })();

  /*
  As the webpage contains the initial USER data (id and name),
  pre-populate the global $Session (the initial $ indicates a global
  variable) with these. This way we spare us an initial AJAX call.
  */


  $Session = new SessionModel(USER);

  /*
  Simple wrapper around the RestipPlugin endpoint '/api/courses'.
  Needs a custom response parser, as it is namespaced like this:
  {courses: [{<1st course>}, {<2nd course>}, ...]}
  */


  window.Courses = Backbone.Collection.extend({
    url: function() {
      return "" + API_URL + "api/courses";
    },
    parse: function(response) {
      return response != null ? response.courses : void 0;
    }
  });

  /*
  ***************************************************************************
  * VIEWS
  ***************************************************************************
  */


  /*
  We use Mustache as template engine. This function makes it a lot
  easier to get a pre-compiled Mustache template.
  */


  compileTemplate = function(name) {
    return Mustache.compile($("#tw-template-" + name).html());
  };

  /*
  The HomeView just renders the "home" template.
  */


  window.HomeView = Backbone.View.extend({
    template: compileTemplate("home"),
    render: function(eventName) {
      this.$el.html(this.template());
      return this;
    }
  });

  /*
  The LoginView renders its template and listens to form submits then
  attempting to login the user:
  */


  window.LoginView = Backbone.View.extend({
    template: compileTemplate("login"),
    render: function(eventName) {
      $(this.el).html(this.template());
      return this;
    },
    /*
      listen to submit events and …
    */

    events: {
      "submit #loginForm": "attemptLogin"
    },
    attemptLogin: function(event) {
      /*
          (Make sure to prevent the default action of the form.)
      */

      var done, fail, password, username;
      event.preventDefault();
      /*
          get the user´s input,
      */

      username = this.$el.find("input[name=username]").val();
      password = this.$el.find("input[name=password]").val();
      /*
          define the callbacks,
      */

      done = function(result) {
        $Session = result;
        return $App.navigate("#home", {
          trigger: true
        });
      };
      fail = function(jqXHR, textStatus) {
        return console.log("fail", arguments);
      };
      $.mobile.showPageLoadingMsg();
      /*
          and authenticate the user.
      */

      return SessionModel.authenticate(username, password, done, fail);
    }
  });

  /*
  
  The MyCoursesView is the most complicated of the views. Its
  responsibilities are:
  
    * to render an empty list <ul/>
    * listen to its collection
    * if an item is added to the collection,
      add a list item to the list
    * if multiple items are added to the collection
      (e.g. after a fetch or reset),
      add every single item to the list.
  */


  window.MyCoursesView = Backbone.View.extend({
    template: compileTemplate("my-courses"),
    /*
      Listen to the events of the collection.
    */

    initialize: function() {
      this.collection.on('add', this.addOne, this);
      this.collection.on('reset', this.addAll, this);
    },
    /*
      Adding a single item consists of creating a view for that item and
      of appending the rendered view to the <ul/> element and then refresh
      the listview.
    */

    addOne: function(course, collection) {
      var item;
      item = new MyCoursesItemView({
        model: course
      });
      this.$("ul").append(item.render().el).listview('refresh');
    },
    /*
      Adding a collection of items by adding every single one with #addOne.
    */

    addAll: function(collection) {
      _.each(collection.models, (function(course) {
        return this.addOne(course);
      }), this);
    },
    render: function() {
      this.$el.html(this.template());
      return this;
    }
  });

  /*
  Each item in the list of my courses has an own view. This way it is
  lot easier to add it to the list of courses and to offer additional
  actions for each one.
  */


  window.MyCoursesItemView = Backbone.View.extend({
    /*
      Each item is a <li/>.
    */

    tagName: "li",
    /*
      Just as an example, a listener for dblclick…
    */

    events: {
      "dblclick": function() {
        return alert(JSON.stringify(this.model));
      }
    },
    template: compileTemplate("my-courses-item"),
    /*
      Render the template filled with the data of the model.
    */

    render: function() {
      this.$el.html(this.template(this.model.toJSON()));
      return this;
    }
  });

  /*
  ***************************************************************************
  * ROUTING
  ***************************************************************************
  */


  /*
  A function combinator that makes ensures that the callback is only
  valid for authorised users. Otherwise `redirect` to the #login page.
  */


  requireSession = function() {
    return function(callback) {
      return function() {
        if ($Session.authenticated()) {
          return callback.apply(this, arguments);
        } else {
          return this.navigate("login", {
            trigger: true
          });
        }
      };
    };
  };

  /*
  The singleton AppRouter containing the handlers for all the routes.
  */


  AppRouter = Backbone.Router.extend({
    /*
      @firstPage is used to prevent sliding in the first page.
    */

    initialize: function() {
      return this.firstPage = true;
    },
    routes: {
      "": "home",
      "home": "home",
      "login": "login",
      "my-courses": "myCourses",
      "course/:id": "course"
    },
    /*
      Authorised route changing page to a HomeView.
    */

    home: requireSession()(function() {
      return this.changePage(new HomeView());
    }),
    /*
      Authorised route changing page to a MyCoursesView.
    
      It instantiates a course collection, changes the page to the
      MyCoursesView (parameterized with that collection) and fetches the
      collection from the server. (In the process the view gets notified
      and renders itself.)
    */

    myCourses: requireSession()(function() {
      var courses;
      courses = new Courses();
      this.changePage(new MyCoursesView({
        collection: courses
      }));
      return courses.fetch();
    }),
    /*
      Just a dummy, authorised route handler. To be continued …
    */

    course: requireSession()(function(id) {
      return alert("Show course: '" + id + "'");
    }),
    /*
      Authorised route changing page to a HomeView.
    */

    login: function() {
      return this.changePage(new LoginView());
    },
    /*
      Internal function to be used by the route handlers.
    
      `page` is a Backbone.View which is added as a jQuery mobile page to
      the pageContainer. Eventually, after all the setup mojo and
      everything is in place, the `jQuery mobile way`(TM) of changing
      pages is invoked.
    */

    changePage: function(page) {
      var transition;
      $(page.el).attr('data-role', 'page');
      page.render();
      $('body').append($(page.el));
      transition = $.mobile.defaultPageTransition;
      if (this.firstPage) {
        transition = 'none';
        this.firstPage = false;
      }
      return $.mobile.changePage($(page.el, {
        changeHash: false,
        transition: transition
      }));
    }
  });

  /*
  ***************************************************************************
  * BOOTSTRAP
  ***************************************************************************
  */


  /*
  Initialize the router and start Backbone hash listening magic
  */


  $(document).ready(function() {
    $App = new AppRouter();
    return Backbone.history.start();
  });

}).call(this);
